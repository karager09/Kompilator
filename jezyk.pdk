nazwa_funkcji arg0 arg1 ->		#strzałeczka przy funkcjach
	dzialanie1,		#"," odzielają instrukcje
	zm1 = 1,
	dzialanie2,
	zm1.		#konczymy kropką, ostatnia wartosc jest wartoscią zwracaną

zm_gl = 2.
zm_gl = 3.43.

funkcja2 r ->
    zm_gl,
    zm_gl = 4,
    r = 1+2*(5/6)- 4,
	obw = (3.14*r)*r, #kolejnosc dzialan
	| obw > 2*3.14*r -> print "jest wieksze";		# "|" reprezentuje "if" % ";" reprezentuje ze beda kolejne, polaczone ze sobą warunki, "," bedzie oznaczal ze to byla pojedncza instrukcja, kolejne ify są ze soba nie polaczone
	| r > 5 -> {
		| 2<3 -> print "tak" nie;
		| true -> print "nie"};		# niech {} będzie reprezentowalo bloki instrukcji
	| true -> print "jest mniejsze",
	zrob_costam 4. # "| true" na koncu reprezentuje "else"



silnia N ->
    zwroc = 0,
	| N>=1 -> zwroc = 1;
	| true -> zwroc = N * (silnia (N- 1)),
	zwroc.


	
	
zmienna_globalna = 7. # zmienna globalna zaimplementowana poza funkcjami, w srodku jest lokalna i przyslania


#glowna funkcja bedzie "main" ktora jest wykonywana po uruchomieniu programu

main ar0 ar1 ->
	wynik = nazwa_funkcji arg0 (arg1+2),
	wynik = wynik/(3+1),
	print wynik,
	funkcja arg0 arg1 arg2,
	null.

# null - specjalna wartosc zwracana, pusta, moze np reprezentowac blad

#ewentualnie moga tez byc tablice

	tab = [1,2,3].
	fr = first tab.
	# w tablicach mozna przechowywac dowolne wartosci
	tab = [1,"costam", [5,6], 5.6].
	nth_elem = nth tab 4.
	
